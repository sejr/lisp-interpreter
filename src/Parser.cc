#include "Parser.h"
#include "../test/Tookit.h"
#include "../test/TestParser.h"

/**
 * This is a helper function that will just iterate through every token that was
 * generated in the lexical analyzer (scanner), and print it off. While this was
 * more useful in earlier parts of the project, its used now only for debugging.
 */
void Parser::printTokens() {
    Token t = scanner.getCurrentToken();
    while (
        t.getTokenType() != eof &&
        t.getTokenType() != error
    ) {
        std::cout << t.repr() << std::endl;
        scanner.moveToNextToken();
        t = scanner.getCurrentToken();
    }
}

/**
 * Here we begin the process of parsing expressions in our lisp program. As long
 * as the current token isn't an EOF, we want to continue iterating through
 * expressions to build our parse tree (see parseExpression() for more info).
 */
void Parser::start() {
    do {

        if (isAtom(scanner.getCurrentToken())) {
            std::cout << scanner.getCurrentToken().repr() << std::endl;
            scanner.moveToNextToken();
        } else {
            ExpressionTreeNode *root = new ExpressionTreeNode();
            parseExpression(root);
            std::cout << printExpression(root->leftChild, isList) << std::endl;
        }
    } while (scanner.getCurrentToken().getTokenType() != eof);
}

/**
 * This method is able to parse a single expression, corresponding to our CFG:
 *
 *     <Start> ::= <Expr> <Start> | <Expr> eof
 *     <Expr>  ::= atom | ( <List> )
 *     <List>  ::= <Expr> <List>
 *
 * The result is a binary parse tree that will allow us to traverse the program
 * later on in our interpreter. In this binary tree, the left child of the root
 * will be the head of a lisp statement, and the right child will be its tail.
 */
void Parser::parseExpression(ExpressionTreeNode *root) {
    // std::cout << scanner.getCurrentToken().repr() << std::endl;
    ExpressionTreeNode *nodeNIL = new ExpressionTreeNode();

    // Scaffold out an empty node.
    ExpressionTreeNode *current = root;
    current->leftChild = nodeNIL;
    current->rightChild = nodeNIL;


    if (isAtom(scanner.getCurrentToken())) {
        // In this case, we have an atom. Construct a ETN with the left child
        // containing the atom itself; the right child remains NIL.
        // std::cout << "atom: " << scanner.getCurrentToken().repr() << std::endl;
        ExpressionTreeNode *newAtomicNode = new ExpressionTreeNode();
        newAtomicNode->atom = scanner.getCurrentToken();
        current->leftChild = newAtomicNode;
        scanner.moveToNextToken();
    } else if (scanner.getCurrentToken().getTokenType() == parenOpen) {
        ExpressionTreeNode *temp = current;
        scanner.moveToNextToken(); // Consume opening parenthesis.
        if (scanner.getCurrentToken().getTokenType() == parenClose) {
            // Here, we have a NIL token.
            scanner.moveToNextToken();
            temp = temp->leftChild;
        } else {
            // We have a LIST.
            // std::cout << "beginlist\n";
            ExpressionTreeNode *newList = new ExpressionTreeNode();
            temp->leftChild = newList;
            while (scanner.getCurrentToken().getTokenType() != parenClose) {
                parseExpression(newList);
                newList = newList->rightChild;
            }

            // std::cout << "endlist\n";
            scanner.moveToNextToken();
        }


    } else {
        std::cout << "Parse error: expected atom (numeric, literal) or list: "
                  << scanner.getCurrentToken().repr()
                  << std::endl;

        exit(EXIT_FAILURE);
    }
}

/**
 * Traverses through a parse tree generated by parseExpression() which allows
 * us to print an expression in a way that is understandable to users.
 */
std::string Parser::printExpression(ExpressionTreeNode *root, bool isList) {
    std::string result = "";

    if (root) {
        if (root->leftChild) {
            result.append("(");
            result.append(printExpression(root->leftChild, IS_NOT_ATOM));
            result.append(" . ");
            if (root->rightChild) {
                result.append(printExpression(root->rightChild, IS_NOT_ATOM));
            } else {
                result.append("NIL");
            }
            result.append(")");
        } else {
            result.append(root->atom.repr());
        }
    }

    return result;
}

bool Parser::isAtom(Token t) {
    return t.getTokenType() == atomLiteral ||
           t.getTokenType() == atomNumeric ||
           t.getTokenType() == nil;
}
