#include "Parser.h"
#include "../test/Tookit.h"
#include "../test/TestParser.h"

/**
 * This is a helper function that will just iterate through every token that was
 * generated in the lexical analyzer (scanner), and print it off. While this was
 * more useful in earlier parts of the project, its used now only for debugging.
 */
void Parser::printTokens() {
    Token t = scanner.getCurrentToken();

    while (
        t.getTokenType() != eof &&
        t.getTokenType() != error
    ) {
        std::cout << t.repr() << std::endl;
        scanner.moveToNextToken();
        t = scanner.getCurrentToken();
    }
}

/**
 * Here we begin the process of parsing expressions in our lisp program. As long
 * as the current token isn't an EOF, we want to continue iterating through
 * expressions to build our parse tree (see parseExpression() for more info).
 */
void Parser::start() {

    // do {
    //     scanner.moveToNextToken();
    // } while (scanner.getCurrentToken().getTokenType() != eof);
}

void Parser::runTests() {
    printExpression_test1(); // TEST1 TEST2 TEST3
    std::cout << std::endl;
    printExpression_test2(); // (ROOT TEST1 TEST2 TEST3)
    std::cout << std::endl;
    printExpression_test3(); // (3 5 (XYZ) 7)
    std::cout << std::endl;
    printExpression_test4(); // (NIL 5 () (()) 7 (() 9 ()) )
    std::cout << std::endl;
    printExpression_test5(); // (DEFUN F23 (X) (PLUS X 12 15))
    std::cout << std::endl;
}

/**
 * This method is able to parse a single expression, corresponding to our CFG:
 *
 *     <Start> ::= <Expr> <Start> | <Expr> eof
 *     <Expr>  ::= atom | ( <List> )
 *     <List>  ::= <Expr> <List>
 *
 * The result is a binary parse tree that will allow us to traverse the program
 * later on in our interpreter. In this binary tree, the left child of the root
 * will be the head of a lisp statement, and the right child will be its tail.
 */
void Parser::parseExpression(ExpressionTreeNode *root) {
    ExpressionTreeNode *current = new ExpressionTreeNode();
    ExpressionTreeNode *leftNode = new ExpressionTreeNode();
    ExpressionTreeNode *rightNode = new ExpressionTreeNode();

    current = root;
    current->leftChild = leftNode;
    current->rightChild = rightNode;

    if (
        scanner.getCurrentToken().getTokenType() == atomLiteral ||
        scanner.getCurrentToken().getTokenType() == atomNumeric
    ) {

        // Handle the case of a particular atom; numeric or literal.
        current->isList = false;
        current->leftChild->atom = scanner.getCurrentToken();
        scanner.moveToNextToken(); // Consume numeric or literal.
        current = current->rightChild;

    } else if (scanner.getCurrentToken().getTokenType() == parenOpen) {
        // Otherwise we have the start of a new list.
        current->isList = true;
        scanner.moveToNextToken();
        ExpressionTreeNode *temp = new ExpressionTreeNode();
        temp = current;

        while (scanner.getCurrentToken().getTokenType() != parenClose) {
            temp = temp->leftChild;
            parseExpression(temp);
        }

        scanner.moveToNextToken(); // Consume numeric or literal.

        current = current->rightChild;

    } else {

        // If neither, then we have a parsing error.
        std::cout << "Parse error: expected atom (numeric, literal) or list: "
                  << scanner.getCurrentToken().repr()
                  << std::endl;

        exit(EXIT_FAILURE);
    }
}

/**
 * Traverses through a parse tree generated by parseExpression() which allows
 * us to print an expression in a way that is understandable to users.
 */
std::string Parser::printExpression(ExpressionTreeNode *root, bool isAtom) {
    std::string result = "";

    if (isAtom) {
        return root->leftChild->atom.repr();
    }

    if (root) {
        if (root->leftChild) {
            if (root->leftChild->atom.repr().compare("NIL") != 0) {
                // We have a real atom; not a placeholder.
                result.append("(");
                result.append(root->leftChild->atom.repr());
                if (root->rightChild) {
                    result.append(" . ");
                    result.append(printExpression(root->rightChild, IS_NOT_ATOM));
                    result.append(")");
                } else {
                    // If there's no more list to check, expand the last
                    // atom into its own identifying list: (ATOM . NIL)
                    result.append(" . ");
                    result.append("NIL");
                    result.append(")");
                }
            } else {
                // We have the start of a new list.
                result.append("(");
                result.append(printExpression(root->leftChild, IS_NOT_ATOM));
                result.append(" . ");
                result.append(printExpression(root->rightChild, IS_NOT_ATOM));
                result.append(")");
            }
        } else {
            result.append("NIL");
        }
    }

    return result;
}
